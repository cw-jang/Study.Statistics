# 04 벡터

# 벡터Vector 는 다른 프로그래밍 언어에서 흔히 접하는 배열의 개념으로, 한 가지 스칼라 데이터 타입의
# 데이터를 저장할 수 있다. 예를 들어, 숫자만 저장하는 배열, 문자열만 저장하는 배열이 벡터에 해당

# R의 벡터는 슬라이스 slice를 제공한다. 슬라이스란 배열의 일부를 잘라낸 뒤 이를 또 다시 배열처럼
# 다루는 개념을 뜻한다.

# 또한, 벡터의 각 셀에는 이름을 부여할 수 있다. 따라서 벡터에 저장된 요소들을 색인을 사용하여
# 접근하는 것뿐 아니라 이름을 사용해서도 접근할 수 있다. 이런 특징을 사용하면 데이터를 좀 더 
# 의미 있는 형태로 저장할 수 있다.

# 벡터 생성
# 벡터는 c()를 사용해 생성하고, names()를 사용해 이름을 부여할 수 있다. 

# c: 주어진 값들을 모아 벡터를 생성한다.
# c( ... ) # 벡터로 모을 R 객체들
# 반환값은 벡터다.

# names: 객체의 이름을 반환한다.
# names <-: 객체의 이름을 저장한다.
# names()는 값을 얻어오는 함수고, names<-()는 값을 할당하는 함수다. 이 생소한 문법의 할당 함수가
# 다른 언어와 다른 점 중 하나다.

# 나열하는 인자들은 벡터의 정의대로 한 가지 유형의 스칼라 타입이어야 한다.
# 만일 서로 다른 타입의 데이터를 섞어서 벡터에 저장하면, 이들 데이터는 한 가지 타입으로 자동 형 변환된다.
# 이때 사용하는 형 변환 규칙은 좀 더 표현력이 높은 데이터 타입으로 변환하는 것이다.
# 정확한 변환 규칙은 NULL < raw < logical < integer < double < complex < character < list < expression 순이다.

# 만약 서로 다른 데이터 타입으로 된 데이터를 다루고 싶다면 리스트를 사용하고, 벡터에서는 늘 한가지 
# 데이터 타입만 사용하는 편이 낫다.

# 벡터는 중첩할 수 없다. 따라서 벡터 안에 벡터를 생성하면 단일 차원의 벡터로 변경된다.
# 중첩된 구조가 필요하다면 역시 리스트를 사용해야 한다.
c(1,2,3)
c(1,2,3,c(1,2,3))

# 연속된 숫자를 저장하는 벡터는 자주 사용되기 때문에 1,2,3 ... 과 같은 값을 저장한 벡터를
# 손쉽게 생성하는 별도의 문법이 있다.(4.4에서 별도설명)

# 벡터의 각 셀에는 names <- () 함수를 사용해 이름을 부여할 수 있다.
# names()의 반환 값에 원하는 이름을 문자열 벡터로 할당하면 된다.
x <- c(1,3,4)
names(x) <- c("kim", "seo", "park")
names(x)


# 벡터 데이터 접근
# 벡터의 데이터를 접근하는 데는 색인을 사용하는 방법과 이름을 사용하는 방법이 있다.
# 또, 벡터에서 특정 요소를 제외한 나머지 데이터를 가져오거나, 동시에 여러 셀의 데이터를 접근하는 것 역시 가능하다. 

# x[n]: 벡터 x의 n번째 요소, n은 숫자 또는 셀의 이름을 뜻하는 문자열
# x[-n]: 벡터 x에서 n번째 요소를 제외한 나머지. n은 숫자 또는 셀의 이름을 뜻하는 문자열
# x[idx_vector]: 벡터 x로부터 idx_vector에 지정된 요소를 얻어옴. 이때 idx_vector는 색인을 표현하는
#		숫자 벡터 또는 셀의 이름을 표현하는 문자열 벡터
# x[start:end]: 벡터 x의 start부터 end까지의 값을 반환함. 반환 값은 start위치의 값과 end위치의 값을
#	모두 포함함

# 다음은 벡터의 길이 관련 함수다.
# length: 객체의 길이를 반환한다.
#	x # R객체, 팩터, 배열, 리스트를 지정한다.
# 반환 값은 객테의 길이다.

# NROW: 배열의 행 또는 열의 수를 반환한다.
#	x # 벡터, 배열 또는 데이터 프레임
# 반환 값은 행의 수다.

# 벡터는 [] 안에 색인을 적어 각 요소를 가져올 수 있다. 이때, 색인은 다른 언어와 달리 1부터 시작한다.
x <- c("a", "b", "c")
x[1]
x[3]

# 또한 '-색인' 형태로 음의 색인을 사용해 특정 요소만 제외할 수도 있다.
x <- c("a","b","c")
x[-1]
x[-2]

# 여러 위치에 저장된 값을 한 번에 가져오려면 '벡터명[색인 벡터]' 형식을 사용한다.
x <- c("a", "b", "c")
x[c(1,2)]

# 'start:end' 형태의 문법은 start부터 end까지의 숫자를 저장한 숫자 벡터를 뜻한다.
# 따라서 x[start:end]를 사용해 start부터 end까지의 데이터(start와 end에 위치한 요소 포함)를 볼 수 있다.
x <- c("a", "b", "c")
x[1:2]
x[1:3]

# 벡터의 각 셀에 names()를 사용해 이름을 부여했다면, 이 이름을 사용해 데이터를 접근할 수 있다.
x <- c(1, 3, 4)
names(x) <- c("kim", "seo", "park")
x
x["seo"]
x[c("seo", "park")]

# 벡터에 부여된 이름만 보려면 이름을 부여할 때와 마찬가지로 names()를 사용한다.
# 다음은 벡터의 두 번째 요소에 부여한 이름이 "seo"임을 보여준다.
names(x) [2]

# 벡터의 길이는 length()또는 NROW()를 통해 알 수 있다(NROW가 대문자임에 주의)
# 본래 nrow()는 뒤에서 설명할 행렬과 데이터 프레임의 행 수를 알려주는 함수지만,
# nrow()의 변형인 NROW()는 인자가 벡터인 경우 벡터를 n행 1열의 행렬로 취급해 
# 길이를 반환한다. 따라서 데이터 타입에 무관하게 길이를 알고 싶은 경우 length(), nrow(), NROW()의
# 구분없이 항상 NROW()만 사용하면 대부분 문제없이 동작한다.
x <- c("a", "b", "c")
length(x)
nrow(x)
NROW(x)

# 벡터 연산
# 벡터는 값을 하나씩 접근해 해당 값을 사용한 계산을 수행하거나, 벡터 전체에 대해 연산을 한 번에
# 수행하거나, 벡터를 집합처럼 취급해 집합 연산(합집합, 교집합, 차집합)을 계산할 수 있다.

# identical: 객체가 동일한지를 판단한다
#	x, # R객체
#	y, # R객체
# 반환값은 x와 y가 동일하면 TRUE, 그렇지 않으면 FALSE이다.

# union: 합집합을 구한다.
#	x, # 벡터
#	y, # 벡터
# 반환값은 x와 y의 합집합이다.

# intersect: 교집합을 구한다.
#	x,	# 벡터
#	y,	# 벡터
# 반환값은 x와 y의 교집합이다.

# setdiff: 차집합을 구한다.
#	x, 	# 벡터
#	y, 	# 벡터
# 반환 값은 x와 y의 차집합이다.

# setequal: x와 y가 같은 집합인지 판단한다.
#	x,	# 벡터
#	y,	# 벡터
# 반환값은 x와y가 같은 집합인지 여부이다.

# value %in% x: 벡터x에 value가 저장되어 있는지 판단함
# x + n: 벡터 x의 모든 요소에 n을 더한 벡터를 구함. 마찬가지로 *,/,-,==등의 연산자를 적용가능

# 두 벡터가 같은 값을 담고 있는지는 identical() 함수로 알 수 있다.
identical(c(1,2,3), c(1,2,3))
identical(c(1,2,3), c(1,2,100))

# %in% 연산자는 어떤 값이 벡터에 포함되어 있는지를 알려준다.
"a" %in% c("a","b","c")
"d" %in% c("a","b","c")

# 벡터 전체 값에 대한 연산을 한 번에 수행하려면 벡터를 마치 하나의 숫자처럼 생각하고 
# 연산을 수행하면 된다. 이와 같이 데이터 전체에 대해 수행하는 연산은 R의 특징 중 하나로,
# 각 요소별로 연산을 수행하는 경우에 비해 실행 속도가 빠르기 때문에 자주 사용한다.(3장 R프로그래밍 참조)

x <- c(1,2,3,4,5)
x + 1
10 - x

# 같은 방법으로 == 또는 != 연산자를 사용해 두 벡터에 저장된 값들을 한 번에 비교할 수 있다.
# 그러나 흔히 if문 등의 조건문에서는 단 하나의 참 또는 거짓 값을 사용해야 하기 때문에 ==, !=가
# 아니라 앞서 설명한 identical()을 사용해야 한다는 점을 기억하기 바란다.
c(1,2,3) == c(1,2,100)
c(1,2,3) != c(1,2,100)

# 벡터를 집합set으로 취급해 집합 간 합집합, 교집합, 차집합을 계산할 수 있다.
union(c("a", "b", "c"), c("a", "d")) # 합집합
intersect(c("a", "b", "c"), c("a", "d")) # 교집합
setdiff(c("a", "b", "c"), c("a", "d"))	# 교집합

# 집합 간 비교에는 setequal()을 사용한다.
setequal(c("a", "b", "c"), c("a", "d"))
setequal(c("a", "b", "c"), c("a", "b", "c", "c"))

# 연속된 숫자로 구성된 벡터
# 다량의 데이터가 있을 때 데이터의 일부를 한번에 잘라서 처리하기 위해 흔히 숫자 색인 값이 저장된 벡터를 
# 사용한다. 또, 연속된 데이터를 한 번에 잘라낼 경우가 많아 연속된 숫자가 저장된 벡터가 종종 필요하다.

# seq: 시퀀스를 생성한다.
#	from, # 시작 값
#	to, # 끝 값
#	by # 증가치
# from부터 to까지의 값을 by 간격으로 저장한 숫자 벡터를 반환한다.

# seq_along: 주어진 객체의 길이만큼 시퀀스를 생성한다.
#	along.width # 이 인자 길이만큼 시퀀스를 생성한다. 
# 반환 값은 along.width의 길이가 N일 때, 1부터 N까지의 숫자를 저장한 벡터다.

# 다음은 시퀀스 생성과 관련한 문법이다.
# from:end from부터 end까지의 숫자를 저장한 벡터를 반환함(from과 end포함)

# seq(from, end, by)는 from부터 end 까지의 값을 저장한 벡터를 반환한다. 여기서 by는 생략 가능하며,
# 이 경우 1씩 증가 또는 감소하는 것으로 자동 지정된다.
seq(3,7)
seq(7,3)
seq(3, 7, 2)
seq(3, 7, 3)

# 1씩 증가 또는 감소하는 벡터의 경우 seq()를 사용하지 않고 'start:end' 형태의 축약형으로도 표현할 수 있다.
3:7
7:3

# 1부터 주어진 벡터의 길이 N까지의 값을 저장한 색인 벡터가 필요한 경우 NROW()로 길이를 얻어 색인 백터를 만들 수 있다.
# 또는 seq_along(x)를 사용해 x의 길이까지의 값을 담은 벡터를 생성할 수 있다.
x <- c(2, 4, 6, 8, 10)
1:NROW(x)
seq_along(x)

# 반복된 값을 저장한 벡터
# 반복된 값을 저장한 벡터는 c(1,1,1,1,2,2,2,2) 또는 c(1,2,1,2,1,2,1,2)처럼 숫자가 반복되는 형태로 나타나는
# 벡터를 뜻한다. 이러한 벡터를 색인 벡터로 사용하면 주어진 데이터를 몇 개 분류로 쉽게 나눌 수 있어 종종 사용한다.
# 반복된 값이 저장된 벡터는 rep()로 생성할 수 있다.

# rep: 주어진 값을 반복한다.
# 	x, # 반복할 값이 저장된 벡터
#	times, # 전체 벡터의 반복 횟수
# 	each, # 개별 값의 반복 횟수
# 반환 갓은 반복된 값이 저장된 x와 같은 타입의 객체다.

# times와 each의 의미는 다음 예를 통해 쉽게 이해할 수 있다. 숫자 1,2 에 대해 tiems=5를 지정하면 1,2의 나열이 
# 5회 반복된다.
rep(1:2, times=5)

# each=5를 지정하면 개별 값이 5회 반복된다. 즉, 1이 5회 반복된 후 2가 5회 반복된다.
rep(1:2, each=5)

# each=5, times=2를 지정하면 개별 값의 5회 반복을 총 2회 반복한다.
rep(1:2, each=5, times=2)
